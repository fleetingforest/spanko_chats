<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Disciplinarian Dashboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script>
        const currentUserDisplayName = "{{ user_name|e }}";
        const aiDisplayName = "{{ ai_name|e }}";

        let activeChat = {
            id: null,
            name: 'New Chat',
            messages: [],
            created_at: null
        };

        let currentSelectedFile = null; // Variable to store the selected file

        function showSection(id) {
            document.querySelectorAll('.section').forEach(sec => sec.style.display = 'none');
            const sectionToShow = document.getElementById(id);
            if (sectionToShow) {
                sectionToShow.style.display = 'block';
            }
            if(id === 'chat') displayChatMessages(); // Refresh chat view
            if(id === 'history') loadHistoryList();
            if(id === 'rules') loadRules();
            if(id === 'punishments') loadPunishments();
            if(id === 'todo') loadTodos();
        }

        async function initializeDashboard() {
            try {
                const res = await fetch('/data/active_chat_session');
                if (!res.ok) {
                    if (res.status === 401) { // Unauthorized
                        window.location.href = "{{ url_for('login') }}";
                        return;
                    }
                    console.error('Failed to load active chat session:', res.status);
                    // Fallback to a new local chat object if server fails unexpectedly
                    activeChat = { id: null, name: 'Error Loading Chat', messages: [], created_at: new Date().toISOString() };
                } else {
                    activeChat = await res.json();
                }
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                activeChat = { id: null, name: 'Network Error', messages: [], created_at: new Date().toISOString() };
            }
            displayChatMessages();
            // updateChatTitle(); // Removed call
            // Show chat section by default
            showSection('chat');
        }

        // Add the formatting function to match backend processing
        function formatAiResponseText(text) {
            if (!text) return text;
            
            // Replace **text** with <b>Text</b> with proper capitalization
            function formatBold(match, content, offset, string) {
                if (!content) return "<b></b>";
                
                const beforeMatch = string.substring(0, offset);
                const shouldCapitalize = offset === 0 || /[.!?\n]\s*$/.test(beforeMatch);
                
                if (shouldCapitalize && content.length > 0) {
                    return `<b>${content[0].toUpperCase() + content.substring(1)}</b>`;
                } else {
                    return `<b>${content}</b>`;
                }
            }
            
            // Replace *text* with <i>Text</i> with proper capitalization
            function formatItalic(match, content, offset, string) {
                if (!content) return "<i></i>";
                
                const beforeMatch = string.substring(0, offset);
                const shouldCapitalize = offset === 0 || /[.!?\n]\s*$/.test(beforeMatch);
                
                if (shouldCapitalize && content.length > 0) {
                    return `<i>${content[0].toUpperCase() + content.substring(1)}</i>`;
                } else {
                    return `<i>${content}</i>`;
                }
            }
            
            // First handle bold (double asterisks)
            text = text.replace(/\*\*([^*]+?)\*\*/g, formatBold);
            // Then handle italics
            text = text.replace(/(?<!\*)\*([^*\n]{1,100}?)\*(?!\*)/g, formatItalic);
            
            return text;
        }

        function displayChatMessages() {
            const chatBox = document.getElementById('chat-box');
            if (!chatBox) return;
            chatBox.innerHTML = ''; // Clear existing messages

            if (!activeChat || !activeChat.messages) {
                console.warn("No active chat or messages to display.");
                return;
            }

            activeChat.messages.forEach((msg, index) => {
                if (msg.role === 'user' || msg.role === 'assistant') {
                    const messageDiv = document.createElement('div');
                    if (msg.role === 'user') {
                        messageDiv.classList.add('user-message');
                        messageDiv.textContent = currentUserDisplayName + ': ' + msg.content;
                    } else { // assistant
                        messageDiv.classList.add('ai-message');
                        // Apply formatting to stored AI messages
                        const formattedContent = formatAiResponseText(msg.content);
                        messageDiv.innerHTML = aiDisplayName + ': ' + formattedContent.replace(/\n/g, '<br>');
                    }
                    chatBox.appendChild(messageDiv);
                }
            });
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        /* Removed updateChatTitle function
        function updateChatTitle() {
            const chatTitleElement = document.getElementById('chat-title'); 
            if (chatTitleElement) {
                let titleToDisplay = activeChat.name;
                if (titleToDisplay === 'New Chat' || titleToDisplay === 'Legacy Chat') {
                    titleToDisplay = ''; 
                }
                chatTitleElement.textContent = titleToDisplay || ''; 
            }
        }
        */

        async function sendMessage() {
            const messageInput = document.getElementById('message-input');
            if (!messageInput) return;
            const messageContent = messageInput.value.trim();

            if (!messageContent && !currentSelectedFile) {
                console.log("No message content and no file selected. Nothing to send.");
                return; // Don't send if both are empty
            }

            const chatBox = document.getElementById('chat-box');
            if (!chatBox) return;

            // --- File Upload Handling (if a file is selected) ---
            let uploadedFileInfo = null;
            if (currentSelectedFile) {
                const formData = new FormData();
                formData.append('file', currentSelectedFile);

                // Display temporary uploading message for the file part
                const tempFileStatusDiv = document.createElement('div');
                tempFileStatusDiv.classList.add('system-message'); // Or a specific style
                tempFileStatusDiv.textContent = `Uploading ${currentSelectedFile.name}...`;
                chatBox.appendChild(tempFileStatusDiv);
                chatBox.scrollTop = chatBox.scrollHeight;

                try {
                    console.log("Attempting to upload file to /upload_file_to_chat before sending message");
                    const uploadResponse = await fetch('/upload_file_to_chat', {
                        method: 'POST',
                        body: formData,
                    });
                    console.log("File upload response status:", uploadResponse.status);

                    chatBox.removeChild(tempFileStatusDiv); // Remove temp uploading message

                    if (!uploadResponse.ok) {
                        let errorData = { error: 'File upload failed: ' + uploadResponse.statusText };
                        try { errorData = await uploadResponse.json(); } catch (e) { console.error("Could not parse upload error JSON"); }
                        console.error('File upload failed:', errorData);
                        alert('Error uploading file: ' + (errorData.error || 'Unknown error'));
                        
                        // Display error in chat for the file upload
                        const fileErrorDiv = document.createElement('div');
                        fileErrorDiv.classList.add('system-message');
                        fileErrorDiv.textContent = `System: Failed to upload ${currentSelectedFile.name}. ` + (errorData.error || '');
                        chatBox.appendChild(fileErrorDiv);
                        chatBox.scrollTop = chatBox.scrollHeight;

                        // Clear selected file and UI indication on critical upload failure
                        currentSelectedFile = null;
                        document.getElementById('file-upload-input').value = ''; // Clear file input
                        const selectedFilenameSpan = document.getElementById('selected-filename');
                        selectedFilenameSpan.textContent = '';
                        selectedFilenameSpan.style.display = 'none';
                        document.getElementById('file-upload-button').style.color = '';
                        return; // Stop message sending process if file upload fails
                    }
                    const uploadResult = await uploadResponse.json();
                    console.log("File upload successful, server response:", uploadResult);
                    if (uploadResult.file_info) {
                        uploadedFileInfo = uploadResult.file_info;
                        // Display a confirmation that file is ready to be sent with message
                        const fileReadyDiv = document.createElement('div');
                        fileReadyDiv.classList.add('system-message');
                        fileReadyDiv.textContent = `System: ${currentSelectedFile.name} is attached.`;
                        chatBox.appendChild(fileReadyDiv);
                        chatBox.scrollTop = chatBox.scrollHeight;
                    } else {
                        console.warn("File uploaded, but server response did not contain expected 'file_info'.");
                        alert("File was uploaded, but there was an issue getting its details. It might not be attached to your message.");
                         // Proceed without uploadedFileInfo if it's missing, or handle as error
                    }
                } catch (uploadError) {
                    console.error('Error during file upload fetch operation:', uploadError);
                    alert('An unexpected error occurred during file upload: ' + uploadError.message);
                    if (tempFileStatusDiv.parentNode === chatBox) chatBox.removeChild(tempFileStatusDiv);
                    
                    const fileErrorDiv = document.createElement('div');
                    fileErrorDiv.classList.add('system-message');
                    fileErrorDiv.textContent = `System: Error uploading ${currentSelectedFile.name}. ` + uploadError.message;
                    chatBox.appendChild(fileErrorDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;

                    // Clear selected file and UI indication on critical upload failure
                    currentSelectedFile = null;
                    document.getElementById('file-upload-input').value = '';
                    const selectedFilenameSpan = document.getElementById('selected-filename');
                    selectedFilenameSpan.textContent = '';
                    selectedFilenameSpan.style.display = 'none';
                    document.getElementById('file-upload-button').style.color = '';
                    return; // Stop message sending process
                }
            } // End of file upload handling

            // --- Regular Message Sending Logic (now includes uploadedFileInfo if present) ---
            const userMessageDiv = document.createElement('div');
            userMessageDiv.classList.add('user-message');
            let displayMessageContent = messageContent;
            if (uploadedFileInfo) {
                // Modify display message if you want to indicate file attachment here, e.g.:
                // displayMessageContent += ` (Attachment: ${uploadedFileInfo.name})`; 
                // For now, the system message "[file] is attached" serves this purpose.
            }
            userMessageDiv.textContent = currentUserDisplayName + ': ' + displayMessageContent;
            chatBox.appendChild(userMessageDiv);

            const userMessageForAI = { 
                role: 'user', 
                content: messageContent 
            };
            if (uploadedFileInfo) {
                userMessageForAI.file_info = uploadedFileInfo;
            }
            activeChat.messages.push(userMessageForAI);
            
            chatBox.scrollTop = chatBox.scrollHeight; 
            messageInput.value = ''; 
            resetTextareaHeight(); 

            // Clear selected file and UI indication AFTER successful setup for sending
            if (currentSelectedFile) {
                currentSelectedFile = null;
                document.getElementById('file-upload-input').value = ''; // Clear file input
                const selectedFilenameSpan = document.getElementById('selected-filename');
                selectedFilenameSpan.textContent = '';
                selectedFilenameSpan.style.display = 'none';
                document.getElementById('file-upload-button').style.color = '';
            }

            // Add typing indicator immediately
            const typingDiv = document.createElement('div');
            typingDiv.className = 'ai-message typing-indicator';
            typingDiv.id = 'typing-indicator';
            typingDiv.innerHTML = aiDisplayName + ' is typing...';
            chatBox.appendChild(typingDiv);
            chatBox.scrollTop = chatBox.scrollHeight;

            try {
                // Use EventSource for streaming
                const eventSource = new EventSource(`/chat_stream_message?message=${encodeURIComponent(messageContent)}`);
                let aiMessageDiv = null;
                let fullAiResponse = '';

                eventSource.onmessage = function(event) {
                    if (event.data === '[DONE]') {
                        eventSource.close();
                        
                        const typingIndicator = document.getElementById('typing-indicator');
                        if (typingIndicator && typingIndicator.parentNode === chatBox) { // Check parentNode
                            chatBox.removeChild(typingIndicator);
                        }

                        if (fullAiResponse) {
                            const finalFormattedResponse = formatAiResponseText(fullAiResponse);
                            // Ensure the message is added to activeChat.messages only once.
                            // Check if the last message is already this AI response to prevent duplicates if [DONE] is processed after a manual addition.
                            const lastMessageInChat = activeChat.messages.length > 0 ? activeChat.messages[activeChat.messages.length - 1] : null;
                            if (!lastMessageInChat || lastMessageInChat.role !== 'assistant' || lastMessageInChat.content !== fullAiResponse) {
                                activeChat.messages.push({ role: 'assistant', content: fullAiResponse }); // Store raw content
                            }
                            
                            // Update the displayed message one final time with complete formatting
                            if (aiMessageDiv) {
                                aiMessageDiv.innerHTML = aiDisplayName + ': ' + finalFormattedResponse.replace(/\n/g, '<br>');
                            }
                        }
                        return;
                    }

                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'start') {
                            // Remove typing indicator and create AI message div
                            const typingIndicator = document.getElementById('typing-indicator');
                            if (typingIndicator && typingIndicator.parentNode === chatBox) { // Ensure it's a child of chatBox
                                chatBox.removeChild(typingIndicator);
                            }
                            
                            aiMessageDiv = document.createElement('div');
                            aiMessageDiv.className = 'ai-message';
                            aiMessageDiv.innerHTML = aiDisplayName + ': ';
                            chatBox.appendChild(aiMessageDiv);
                            chatBox.scrollTop = chatBox.scrollHeight;
                            fullAiResponse = ''; // Reset the accumulator
                        }
                        else if (data.type === 'content' && aiMessageDiv) {
                            // Append new content to accumulator
                            fullAiResponse += data.content;
                            
                            // For display, apply formatting to the complete accumulated text
                            // But be careful not to over-format
                            const displayContent = fullAiResponse;
                            const formattedForDisplay = formatAiResponseText(displayContent);
                            aiMessageDiv.innerHTML = aiDisplayName + ': ' + formattedForDisplay.replace(/\n/g, '<br>');
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                        else if (data.type === 'metadata' && data.chat_name) {
                            // Update chat name if provided
                            activeChat.name = data.chat_name;
                        }
                        else if (data.type === 'complete') {
                            // Handle completion and suggestions
                            if (data.suggestion) {
                                showSuggestionModal(data.suggestion);
                            }
                        }
                        else if (data.type === 'error') {
                            console.error('Stream error:', data.message);
                            if (aiMessageDiv) {
                                aiMessageDiv.innerHTML = aiDisplayName + ': Error: ' + data.message;
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parsing stream data:', parseError);
                    }
                };

                eventSource.onerror = function(error) {
                    console.error('EventSource error:', error);
                    eventSource.close();
                    
                    // Remove typing indicator
                    const typingIndicator = document.getElementById('typing-indicator');
                    if (typingIndicator && typingIndicator.parentNode === chatBox) { // Ensure it's a child of chatBox
                        chatBox.removeChild(typingIndicator);
                    }
                    
                    // Show error message
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'ai-message';
                    errorDiv.innerHTML = aiDisplayName + ': Connection error. Please try again.';
                    chatBox.appendChild(errorDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                };

            } catch (error) {
                console.error('Failed to start stream:', error);
                // Remove typing indicator
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator && typingIndicator.parentNode === chatBox) { // Ensure it's a child of chatBox
                    chatBox.removeChild(typingIndicator);
                }
                
                // Fall back to regular POST request
                try {
                    const fetchBody = { message: messageContent }; // Original body
                    if (uploadedFileInfo) {
                        fetchBody.file_info = uploadedFileInfo; // Add file_info if present
                    }

                    const res = await fetch('/chat', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(fetchBody) 
                    });

                    let aiReplyText = null; // To store AI reply for analysis

                    if (!res.ok) {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.reply || errorMsg;
                        } catch (e) { /* ignore parsing error if not json */ }
                        
                        const aiErrorMessage = { role: 'assistant', content: `Error: ${errorMsg}` };
                        activeChat.messages.push(aiErrorMessage);
                        console.error('Chat API error:', errorMsg);
                    } else {
                        const data = await res.json();
                        const aiMessage = { role: 'assistant', content: data.reply };
                        activeChat.messages.push(aiMessage);
                        if (data.chat_name && activeChat.name !== data.chat_name) {
                            activeChat.name = data.chat_name;
                        }
                        aiReplyText = data.reply; // Store AI reply for later analysis
                    }
                    
                    // Display AI message (or error) from fallback immediately by re-rendering
                    displayChatMessages(); 
                    chatBox.scrollTop = chatBox.scrollHeight; // Scroll after AI message

                    // Analyze AI message AFTER it's been displayed
                    if (aiReplyText && aiReplyText.trim() !== "") { 
                        // Call analysis asynchronously (fire and forget from UI perspective)
                        analyzeMessageForActions(aiReplyText).catch(error => {
                            console.error("Error during background message analysis:", error);
                        });
                    }

                } catch (fallbackError) {
                    console.error('Failed to send message via fallback:', fallbackError);
                    const networkErrorMessage = { role: 'assistant', content: 'Network error or server issue.' };
                    activeChat.messages.push(networkErrorMessage);
                    displayChatMessages(); // Display network error immediately
                    chatBox.scrollTop = chatBox.scrollHeight; // Scroll after network error
                }
            }
        }

        // Renamed from handleFileUpload and modified behavior
        function handleFileSelected() {
            console.log("handleFileSelected called");
            const fileInput = document.getElementById('file-upload-input');
            const selectedFilenameSpan = document.getElementById('selected-filename');
            const fileUploadButton = document.getElementById('file-upload-button');

            if (fileInput.files && fileInput.files.length > 0) {
                currentSelectedFile = fileInput.files[0];
                console.log("File selected:", currentSelectedFile.name);
                selectedFilenameSpan.textContent = currentSelectedFile.name;
                selectedFilenameSpan.style.display = 'inline';
                fileUploadButton.style.color = 'var(--primary-color)'; // Indicate file is selected
            } else {
                currentSelectedFile = null;
                selectedFilenameSpan.textContent = '';
                selectedFilenameSpan.style.display = 'none';
                fileUploadButton.style.color = ''; // Reset color
                console.log("No file selected or selection cleared.");
            }
        }

        async function loadHistoryList(){
            const historyListEl = document.getElementById('history-list');
            if (!historyListEl) return;
            historyListEl.innerHTML = '<li>Loading history...</li>';
            try {
                const res = await fetch('/data/history_list');
                const historyItems = await res.json();
                historyListEl.innerHTML = ''; // Clear loading/previous items
                if (historyItems.length === 0) {
                    historyListEl.innerHTML = '<li>No past conversations found.</li>';
                    return;
                }
                historyItems.forEach(chatSummary => { 
                    const li = document.createElement('li');
                    const date = new Date(chatSummary.created_at).toLocaleString();
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${chatSummary.name || 'Unnamed Chat'} (Started: ${date})`; 
                    textSpan.style.cursor = 'pointer';
                    textSpan.onclick = async () => {
                        try {
                            const selectRes = await fetch('/select_chat_session/' + chatSummary.id, { method: 'POST' });
                            if (!selectRes.ok) throw new Error(`Failed to select chat: ${selectRes.status}`);
                            activeChat = await selectRes.json();
                            showSection('chat'); // Switches view and calls displayChatMessages
                            // updateChatTitle(); // Removed call
                        } catch (err) {
                            console.error("Error selecting chat from history:", err);
                            alert("Could not load selected chat.");
                        }
                    };
                    li.appendChild(textSpan);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.style.marginLeft = '10px';
                    deleteButton.style.padding = '2px 8px'; // Smaller padding for a less intrusive button
                    deleteButton.onclick = (event) => {
                        event.stopPropagation(); // Prevent li click event from firing
                        deleteChatFromHistory(chatSummary.id);
                    };
                    li.appendChild(deleteButton);
                    
                    historyListEl.appendChild(li);
                });
            } catch (error) {
                console.error("Failed to load history list:", error);
                historyListEl.innerHTML = '<li>Error loading history.</li>';
            }
        }

        async function deleteChatFromHistory(chatId) {
            if (confirm(`Are you sure you want to delete this chat session? This action cannot be undone.`)) {
                try {
                    const res = await fetch(`/delete_chat_session/${chatId}`, {
                        method: 'POST'
                    });
                    if (res.ok) {
                        // Attempt to get a success message, if any, though not strictly necessary
                        try {
                            const data = await res.json();
                            console.log(data.message || "Chat deleted successfully.");
                        } catch (e) {
                            // If response is not JSON, but still ok, log success
                            console.log("Chat deleted successfully (non-JSON response).");
                        }
                        if (activeChat && activeChat.id === chatId) {
                            // If the deleted chat was the active one, start a new chat
                            await startNewChat(); 
                        }
                        loadHistoryList(); // Refresh the history list
                    } else {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.message || errorMsg;
                        } catch (e) {
                            // If JSON parsing fails, try to get text content
                            try {
                                const textError = await res.text();
                                if (textError) errorMsg = textError;
                            } catch (textE) {
                                // Fallback if text parsing also fails
                                errorMsg = `Failed to delete chat. Server returned ${res.status}. Could not parse error response.`;
                            }
                        }
                        alert(`Error deleting chat: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Failed to delete chat session:', error);
                    alert('Failed to delete chat session. Network error or server issue. Check console for details.');
                }
            }
        }

        async function clearAllHistory() {
            if (confirm('Are you sure you want to delete ALL chat history? This action cannot be undone.')) {
                try {
                    const res = await fetch('/clear_all_history', {
                        method: 'POST'
                    });
                    if (res.ok) {
                        // If the current active chat was deleted, start a new chat
                        await startNewChat();
                        loadHistoryList(); // Refresh the history list
                        console.log('All chat history cleared successfully.');
                    } else {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.message || errorMsg;
                        } catch (e) {
                            try {
                                const textError = await res.text();
                                if (textError) errorMsg = textError;
                            } catch (textE) {
                                errorMsg = `Failed to clear history. Server returned ${res.status}.`;
                            }
                        }
                        alert(`Error clearing all history: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Failed to clear all history:', error);
                    alert('Failed to clear all history. Network error or server issue.');
                }
            }
        }

        async function startNewChat() {
            // 1. Prepare local state and UI for a new chat - CLEAR EVERYTHING
            activeChat = {
                id: 'temp-' + Date.now(), // Temporary ID, will be replaced by server ID
                name: 'New Chat',
                messages: [], // Start with empty messages
                created_at: new Date().toISOString()
            };
            
            // Clear the chat display immediately
            const chatBox = document.getElementById('chat-box');
            if (chatBox) {
                chatBox.innerHTML = ''; // Clear all existing messages
            }
            
            displayChatMessages(); // This will ensure the UI reflects the empty state
            showSection('chat');   // Ensure chat section is visible

            let loadingIndicator = document.getElementById('new-chat-loading-indicator');
            if (loadingIndicator) loadingIndicator.remove(); // Remove previous if any

            if (chatBox) {
                loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'ai-message typing-indicator'; // Reuse existing style
                loadingIndicator.id = 'new-chat-loading-indicator';
                loadingIndicator.innerHTML = aiDisplayName + ' is preparing a new conversation...';
                chatBox.appendChild(loadingIndicator);
                chatBox.scrollTop = chatBox.scrollHeight;
            }

            // 2. Connect to the streaming endpoint
            const eventSource = new EventSource('/new_chat_session_stream');
            let aiMessageDiv = null;
            let accumulatedAiMessageContent = "";

            eventSource.onmessage = function(event) {
                if (event.data === '[DONE]') {
                    eventSource.close();
                    // Finalize the message in activeChat.messages
                    if (activeChat && activeChat.id && activeChat.id !== ('temp-' + Date.now()) && accumulatedAiMessageContent) {
                        // Only add if we don't already have this message
                        const existingAiMsg = activeChat.messages.find(m => m.role === 'assistant');
                        if (!existingAiMsg) {
                            activeChat.messages.push({ role: 'assistant', content: accumulatedAiMessageContent });
                        } else if (existingAiMsg.content !== accumulatedAiMessageContent && !existingAiMsg.content.startsWith("Error:")) {
                            // Update existing message if content differs and it's not an error
                            existingAiMsg.content = accumulatedAiMessageContent;
                        }
                    }
                    return;
                }

                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init_chat') {
                        const newChatData = data.data;
                        // Update activeChat with server data
                        activeChat.id = newChatData.id;
                        activeChat.name = newChatData.name;
                        activeChat.created_at = newChatData.created_at;
                        activeChat.messages = []; // Ensure messages start empty

                        if (loadingIndicator) {
                            loadingIndicator.remove();
                            loadingIndicator = null;
                        }
                        
                        // Create the div for AI's message
                        aiMessageDiv = document.createElement('div');
                        aiMessageDiv.className = 'ai-message';
                        aiMessageDiv.innerHTML = aiDisplayName + ': '; // Initial part
                        if (chatBox) chatBox.appendChild(aiMessageDiv); // Append to chatBox
                        chatBox.scrollTop = chatBox.scrollHeight;
                        accumulatedAiMessageContent = ""; // Reset accumulator

                    } else if (data.type === 'content') {
                        if (aiMessageDiv) {
                            accumulatedAiMessageContent += data.content;
                            // Apply formatting to the complete accumulated content
                            const formattedContent = formatAiResponseText(accumulatedAiMessageContent);
                            aiMessageDiv.innerHTML = aiDisplayName + ': ' + formattedContent.replace(/\n/g, '<br>');
                            chatBox.scrollTop = chatBox.scrollHeight;
                        }
                    } else if (data.type === 'error') {
                        console.error('Stream error from server:', data.message);
                        eventSource.close();
                        if (loadingIndicator) loadingIndicator.remove();
                        if (aiMessageDiv && aiMessageDiv.parentNode === chatBox) aiMessageDiv.remove(); // Check parentNode
                        
                        const errorDisplay = document.createElement('div');
                        errorDisplay.className = 'ai-message';
                        errorDisplay.innerHTML = aiDisplayName + ': Error starting new chat. ' + (data.message || "Please try again.");
                        chatBox.appendChild(errorDisplay);
                        
                        // Reset activeChat to a clean state on error
                        activeChat = {
                            id: null,
                            name: 'New Chat',
                            messages: [{role: 'assistant', content: "Error starting new chat: " + (data.message || "Please try again.")}],
                            created_at: new Date().toISOString()
                        };
                        chatBox.scrollTop = chatBox.scrollHeight;
                    }
                } catch (parseError) {
                    console.error('Error parsing stream data:', parseError, 'Raw data:', event.data);
                }
            };

            eventSource.onerror = function(error) {
                console.error('EventSource failed:', error);
                eventSource.close();
                if (loadingIndicator) {
                    loadingIndicator.remove();
                    loadingIndicator = null;
                }
                if (aiMessageDiv && aiMessageDiv.parentNode === chatBox) { // Check parentNode
                    aiMessageDiv.innerHTML = aiDisplayName + ': Connection error. Please try again.';
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'ai-message';
                    errorDiv.innerHTML = aiDisplayName + ': Connection error. Please try again.';
                    chatBox.appendChild(errorDiv);
                }
                
                // Reset activeChat to a clean state on connection error
                activeChat = {
                    id: null,
                    name: 'New Chat',
                    messages: [{role: 'assistant', content: "Connection error. Please try again."}],
                    created_at: new Date().toISOString()
                };
                chatBox.scrollTop = chatBox.scrollHeight;
            };
        }

        async function loadRules(){
            const rulesList = document.getElementById('rules-list');
            if (!rulesList) return;
            rulesList.innerHTML = '<li>Loading...</li>'; // Add loading indicator
            try {
                const res = await fetch('data/rules');
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                const rules = await res.json();
                rulesList.innerHTML = '';
                if (rules.length === 0) rulesList.innerHTML = '<li>No rules defined.</li>';
                rules.forEach(r => { 
                    const li = document.createElement('li'); 
                    li.textContent = r; 
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.style.marginLeft = '10px';
                    deleteButton.onclick = () => deleteRule(r);
                    li.appendChild(deleteButton);
                    
                    rulesList.appendChild(li); 
                });
            } catch (error) {
                console.error('Failed to load rules:', error);
                rulesList.innerHTML = '<li>Error loading rules.</li>';
            }
        }
        async function addRule() {
            const ruleInput = document.getElementById('new-rule-input');
            if (!ruleInput || !ruleInput.value.trim()) return;
            try {
                const res = await fetch('data/rules', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({rule: ruleInput.value.trim()})
                });
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                ruleInput.value = '';
                loadRules();
            } catch (error) {
                console.error('Failed to add rule:', error);
                alert('Failed to add rule.');
            }
        }

        async function deleteRule(ruleText) {
            if (confirm(`Are you sure you want to delete this rule: "${ruleText}"?`)) {
                try {
                    const res = await fetch('data/rules/delete', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({rule: ruleText})
                    });
                    if (res.ok) {
                        loadRules();
                    } else {
                        const errorData = await res.json().catch(() => ({error: 'Unknown error'}));
                        alert(`Error deleting rule: ${errorData.error}`);
                    }
                } catch (error) {
                    console.error('Failed to delete rule:', error);
                    alert('Failed to delete rule. Check console for details.');
                }
            }
        }

        async function loadPunishments(){
            const punishmentsList = document.getElementById('punishments-list');
            if (!punishmentsList) return;
            punishmentsList.innerHTML = '<li>Loading...</li>';
            try {
                const res = await fetch('data/punishments');
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                const items = await res.json();
                punishmentsList.innerHTML = '';
                if (items.length === 0) punishmentsList.innerHTML = '<li>No punishments recorded.</li>';
                items.forEach(p => { 
                    const li = document.createElement('li'); 
                    li.textContent = p.text + (p.completed ? ' (done)' : ''); 
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.style.marginLeft = '10px';
                    deleteButton.onclick = () => deletePunishment(p.text);
                    li.appendChild(deleteButton);

                    punishmentsList.appendChild(li); 
                });
            } catch (error) {
                console.error('Failed to load punishments:', error);
                punishmentsList.innerHTML = '<li>Error loading punishments.</li>';
            }
        }
         async function addPunishment() {
            const punishmentInput = document.getElementById('new-punishment-input');
            if (!punishmentInput || !punishmentInput.value.trim()) return;
            try {
                const res = await fetch('data/punishments', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({punishment: punishmentInput.value.trim()})
                });
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                punishmentInput.value = '';
                loadPunishments();
            } catch (error) {
                console.error('Failed to add punishment:', error);
                alert('Failed to add punishment.');
            }
        }

        async function deletePunishment(punishmentText) {
            if (confirm(`Are you sure you want to delete this punishment: "${punishmentText}"?`)) {
                try {
                    const res = await fetch('data/punishments/delete', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({punishment_text: punishmentText})
                    });
                    if (res.ok) {
                        loadPunishments();
                    } else {
                        const errorData = await res.json().catch(() => ({error: 'Unknown error'}));
                        alert(`Error deleting punishment: ${errorData.error}`);
                    }
                } catch (error) {
                    console.error('Failed to delete punishment:', error);
                    alert('Failed to delete punishment. Check console for details.');
                }
            }
        }

        async function loadTodos(){
            const todoList = document.getElementById('todo-list');
            if (!todoList) return;
            todoList.innerHTML = '<li>Loading...</li>';
            try {
                const res = await fetch('data/to_dos');
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                const items = await res.json();
                todoList.innerHTML = '';
                if (items.length === 0) todoList.innerHTML = '<li>No to-do items.</li>';
                items.forEach(t => { 
                    const li = document.createElement('li'); 
                    li.textContent = t.text + (t.completed ? ' (done)' : ''); 
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.style.marginLeft = '10px';
                    deleteButton.onclick = () => deleteTodo(t.text);
                    li.appendChild(deleteButton);

                    todoList.appendChild(li); 
                });
            } catch (error) {
                console.error('Failed to load todos:', error);
                todoList.innerHTML = '<li>Error loading to-dos.</li>';
            }
        }
        async function addTodo() {
            const todoInput = document.getElementById('new-todo-input');
            if (!todoInput || !todoInput.value.trim()) return;
            try {
                const res = await fetch('data/to_dos', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({item: todoInput.value.trim()})
                });
                if (!res.ok) throw new Error(`HTTP error ${res.status}`);
                todoInput.value = '';
                loadTodos();
            } catch (error) {
                console.error('Failed to add to-do:', error);
                alert('Failed to add to-do.');
            }
        }

        async function deleteTodo(todoText) {
            if (confirm(`Are you sure you want to delete this to-do item: "${todoText}"?`)) {
                try {
                    const res = await fetch('data/to_dos/delete', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({todo_text: todoText})
                    });
                    if (res.ok) {
                        loadTodos();
                    } else {
                        const errorData = await res.json().catch(() => ({error: 'Unknown error'}));
                        alert(`Error deleting to-do item: ${errorData.error}`);
                    }
                } catch (error) {
                    console.error('Failed to delete to-do item:', error);
                    alert('Failed to delete to-do item. Check console for details.');
                }
            }
        }

        async function clearAllRules() {
            if (confirm('Are you sure you want to delete ALL rules? This action cannot be undone.')) {
                try {
                    const res = await fetch('/clear_all_rules', {
                        method: 'POST'
                    });
                    if (res.ok) {
                        loadRules();
                        console.log('All rules cleared successfully.');
                    } else {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.message || errorMsg;
                        } catch (e) {
                            try {
                                const textError = await res.text();
                                if (textError) errorMsg = textError;
                            } catch (textE) {
                                errorMsg = `Failed to clear rules. Server returned ${res.status}.`;
                            }
                        }
                        alert(`Error clearing all rules: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Failed to clear all rules:', error);
                    alert('Failed to clear all rules. Network error or server issue.');
                }
            }
        }

        async function clearAllPunishments() {
            if (confirm('Are you sure you want to delete ALL punishments? This action cannot be undone.')) {
                try {
                    const res = await fetch('/clear_all_punishments', {
                        method: 'POST'
                    });
                    if (res.ok) {
                        loadPunishments();
                        console.log('All punishments cleared successfully.');
                    } else {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.message || errorMsg;
                        } catch (e) {
                            try {
                                const textError = await res.text();
                                if (textError) errorMsg = textError;
                            } catch (textE) {
                                errorMsg = `Failed to clear punishments. Server returned ${res.status}.`;
                            }
                        }
                        alert(`Error clearing all punishments: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Failed to clear all punishments:', error);
                    alert('Failed to clear all punishments. Network error or server issue.');
                }
            }
        }

        async function clearAllTodos() {
            if (confirm('Are you sure you want to delete ALL to-do items? This action cannot be undone.')) {
                try {
                    const res = await fetch('/clear_all_todos', {
                        method: 'POST'
                    });
                    if (res.ok) {
                        loadTodos();
                        console.log('All todos cleared successfully.');
                    } else {
                        let errorMsg = `Error: ${res.status} ${res.statusText}`;
                        try {
                            const errorData = await res.json();
                            errorMsg = errorData.error || errorData.message || errorMsg;
                        } catch (e) {
                            try {
                                const textError = await res.text();
                                if (textError) errorMsg = textError;
                            } catch (textE) {
                                errorMsg = `Failed to clear todos. Server returned ${res.status}.`;
                            }
                        }
                        alert(`Error clearing all todos: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Failed to clear all todos:', error);
                    alert('Failed to clear all todos. Network error or server issue.');
                }
            }
        }

        // Functions for AI Suggestion Modal
        let suggestionQueue = [];
        let isProcessingSuggestion = false;

        function showSuggestionModal(suggestion) {
            // Handle both single suggestions and arrays
            if (Array.isArray(suggestion)) {
                suggestionQueue = [...suggestion];
                processNextSuggestion();
            } else if (suggestion && suggestion.type && suggestion.text) {
                suggestionQueue = [suggestion];
                processNextSuggestion();
            }
        }

        function processNextSuggestion() {
            if (isProcessingSuggestion || suggestionQueue.length === 0) {
                return;
            }
            
            isProcessingSuggestion = true;
            const currentSuggestion = suggestionQueue.shift();
            
            document.getElementById('suggestionText').value = currentSuggestion.text;
            document.getElementById('suggestionOriginalType').value = currentSuggestion.type;
            
            // Update modal title to show progress if multiple suggestions
            const modalTitle = document.querySelector('#suggestionModal h3');
            if (modalTitle) {
                const remainingCount = suggestionQueue.length;
                const totalProcessed = suggestionQueue.length > 0 ? `(${remainingCount + 1} remaining)` : '';
                modalTitle.textContent = `${aiDisplayName}'s suggestion: Add ${currentSuggestion.type} ${totalProcessed}`;
            }
            
            // Update the suggestion description text
            const suggestionDescription = document.querySelector('#suggestionModal p');
            if (suggestionDescription) {
                suggestionDescription.innerHTML = `${aiDisplayName} suggests adding the following <strong id="suggestionType">${currentSuggestion.type}</strong>:`;
            }
            
            document.getElementById('suggestionModal').style.display = 'block';

            const confirmBtn = document.getElementById('confirmSuggestionBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            
            newConfirmBtn.onclick = async () => {
                const editedText = document.getElementById('suggestionText').value.trim();
                if (!editedText) {
                    alert('Suggestion text cannot be empty.');
                    return;
                }
                const type = document.getElementById('suggestionOriginalType').value;

                try {
                    if (type === 'rule') {
                        document.getElementById('new-rule-input').value = editedText;
                        await addRule();
                    } else if (type === 'punishment') {
                        document.getElementById('new-punishment-input').value = editedText;
                        await addPunishment();
                    } else if (type === 'todo') {
                        document.getElementById('new-todo-input').value = editedText;
                        await addTodo();
                    }
                    
                    // Close modal without skip prompt since user accepted the suggestion
                    closeSuggestionModalSilently();
                    
                    // Process next suggestion if any remain
                    setTimeout(() => {
                        processNextSuggestion();
                    }, 1000); // Increased delay to 1 second for better UX
                    
                } catch (error) {
                    console.error('Error adding suggested item:', error);
                    alert('Failed to add suggested item: ' + (error.message || 'Unknown error'));
                }
            };
        }

        function closeSuggestionModal() {
            document.getElementById('suggestionModal').style.display = 'none';
            document.getElementById('suggestionText').value = '';
            isProcessingSuggestion = false;
            
            // Process next suggestion if any remain (no skip prompt)
            setTimeout(() => {
                processNextSuggestion();
            }, 1000);
        }

        function closeSuggestionModalSilently() {
            document.getElementById('suggestionModal').style.display = 'none';
            document.getElementById('suggestionText').value = '';
            isProcessingSuggestion = false;
        }

        async function analyzeMessageForActions(messageText) {
            if (!messageText || messageText.trim() === "") return;
            console.log("Analyzing AI message for actions:", messageText.substring(0, 100) + "...");
            try {
                const res = await fetch('/analyze_message_for_actions', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({message: messageText})
                });
                if (!res.ok) {
                    const errorData = await res.json().catch(() => ({ error: `HTTP error ${res.status}` }));
                    console.error('Failed to analyze message with AI:', errorData.error);
                    return;
                }
                const suggestion = await res.json();
                if (suggestion) {
                    console.log("AI Suggestion received:", suggestion);
                    showSuggestionModal(suggestion);
                } else {
                    console.log("No actionable suggestion from AI or invalid format received.");
                }
            } catch (error) {
                console.error('Error calling /analyze_message_for_actions:', error);
            }
        }


        function resetTextareaHeight() {
            const textarea = document.getElementById('message-input');
            if (textarea) {
                textarea.style.height = 'auto'; // Reset height
                textarea.style.height = (textarea.scrollHeight) + 'px'; // Set to scroll height
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            initializeDashboard();

            const messageInput = document.getElementById('message-input');
            if (messageInput) {
                messageInput.addEventListener('input', resetTextareaHeight);
                resetTextareaHeight(); // Initial resize
                messageInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault(); 
                        sendMessage();
                    }
                });
            }
        });
    </script>
</head>
<body>
    <h1>Welcome, {{ user_name }}</h1> <!-- Changed from session.get to direct variable -->
    <nav>
        <button onclick="showSection('chat')">Chat</button>
        <button onclick="showSection('history')">History</button>
        <button onclick="showSection('rules')">Rules</button>
        <button onclick="showSection('punishments')">Punishments</button>
        <button onclick="showSection('todo')">To-Do</button>
        <!-- Add a logout link/button if desired -->
        <a href="{{ url_for('logout') if 'user_email' in session else url_for('login') }}" style="margin-left: auto; padding: 10px 15px; color: white; background-color: var(--secondary-color); border-radius: 20px; text-decoration: none;">
            {{ 'Logout' if 'user_email' in session else 'Login' }}
        </a>
    </nav>
    <!-- You might want a title display for the current chat -->
    <!-- <h2 id="chat-title">Chat</h2> -->
    <div id="chat" class="section">
        {% include 'chat_section.html' %}
    </div>
    <div id="history" class="section" style="display:none">
        {% include 'history_section.html' %}
    </div>
    <div id="rules" class="section" style="display:none">
        {% include 'rules_section.html' %}
    </div>
    <div id="punishments" class="section" style="display:none">
        {% include 'punishments_section.html' %}
    </div>
    <div id="todo" class="section" style="display:none">
        {% include 'todo_section.html' %}
    </div>

    <!-- Suggestion Modal -->
    <div id="suggestionModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeSuggestionModal()">&times;</span>
            <h3 id="suggestionModalTitle">[Name]'s Suggestion</h3>
            <p>[Name] suggests adding the following <strong id="suggestionType"></strong>:</p>
            <textarea id="suggestionText" rows="3" style="width: 100%; margin-bottom: 10px; box-sizing: border-box; padding: 8px; border-radius: 4px; border: 1px solid var(--border-color);"></textarea>
            <input type="hidden" id="suggestionOriginalType">
            <button id="confirmSuggestionBtn">Add Item</button>
            <button onclick="closeSuggestionModal()" class="cancel-suggestion-btn">Cancel</button>
        </div>
    </div>
</body>
</html>
